<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>spring+redis实现redissession共享</title>
      <link href="/2018/05/27/spring+redis%E5%AE%9E%E7%8E%B0redissession%E5%85%B1%E4%BA%AB/"/>
      <url>/2018/05/27/spring+redis%E5%AE%9E%E7%8E%B0redissession%E5%85%B1%E4%BA%AB/</url>
      <content type="html"><![CDATA[<h1 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="xml配置"><a href="#xml配置" class="headerlink" title="xml配置"></a>xml配置</h1><h2 id="配置SpringMVC"><a href="#配置SpringMVC" class="headerlink" title="配置SpringMVC"></a>配置SpringMVC</h2><p>spring-mvc.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--将session放入redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisHttpSessionConfiguration"</span> <span class="attr">class</span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--初始化cookie信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieSerializer"</span> <span class="attr">ref</span>=<span class="string">"cookieSerializer"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--session过期时间--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxInactiveIntervalInSeconds"</span> <span class="attr">value</span>=<span class="string">"600"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义cookie session名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cookieSerializer"</span>   <span class="attr">class</span>=<span class="string">"org.springframework.session.web.http.DefaultCookieSerializer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookieName"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置redis连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisPoolConfig"</span> <span class="attr">class</span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--允许开启的最大连接数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxTotal"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--最大空闲连接数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--jedis连接工厂配置</span></span><br><span class="line"><span class="comment">    destroy-method : 容器销毁之前执行的方法</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jedisConnectionFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> <span class="attr">destroy-method</span>=<span class="string">"destroy"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hostName"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.host&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"port"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.port&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;redis.pass&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"3000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usePool"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolConfig"</span> <span class="attr">ref</span>=<span class="string">"jedisPoolConfig"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="web-xml添加拦截器"><a href="#web-xml添加拦截器" class="headerlink" title="web.xml添加拦截器"></a>web.xml添加拦截器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加redis session拦截器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>springSessionRepositoryFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="使用spring-session"><a href="#使用spring-session" class="headerlink" title="使用spring-session"></a>使用spring-session</h1><p>只要使用标准的servlet api调用session，在底层就会通过Spring Session得到的，并且会存储到Redis或其他你所选择的数据源中。</p><p>这里是我写的一个demo:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSession</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson = <span class="keyword">new</span> GsonBuilder().setDateFormat(<span class="string">"yyyyMMddHHmmss"</span>).create();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request, String username)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        request.getSession().setAttribute(<span class="string">"user"</span>, gson.toJson(<span class="keyword">new</span> User(username,<span class="string">"123456"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(HttpServletRequest request, Model model)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        User user = gson.fromJson(request.getSession().getAttribute(<span class="string">"user"</span>).toString(), User.class);</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"user"</span>, user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><strong>首先访问 <code>http://localhost:8080/login?username=%E5%BC%A0%E4%B8%89</code> 来触发生成session。</strong><br><img src="/images/redisSession/1527389828788.jpg" alt="enter description here" title="1527389828788.jpg"></p><p><strong>查看redis，发现session已经保存到redis。</strong><br><img src="/images/redisSession/1527389317833.jpg" alt="enter description here" title="1527389317833.jpg"></p><p><strong>访问 <code>http://localhost:8080/index</code> 获取redis中sessiion信息</strong><br><img src="/images/redisSession/1527389648332.jpg" alt="enter description here" title="1527389648332.jpg"></p><p><strong>访问第二个启动实例 <code>http://localhost:8081/index</code> 回去redis中session信息</strong><br><img src="/images/redisSession/1527389695362.jpg" alt="enter description here" title="1527389695362.jpg"></p><p><strong>至此发现两个启动实例中，都可以访问到redis中的session信息，说明，测试成功。</strong></p><hr><p>项目地址：<a href="https://github.com/hlmk/project/tree/master/studyProject/spring_redis_session" target="_blank" rel="noopener">https://github.com/hlmk/project/tree/master/studyProject/spring_redis_session</a></p><p>可以在浏览器装 Octotree 插件更好的浏览github代码<br><img src="/images/redisSession/1527383267873.jpg" alt="enter description here" title="1527383267873.jpg"><br>效果如下图<br><img src="/images/redisSession/1527383323053.jpg" alt="enter description here" title="1527383323053.jpg"></p><p>参考博客：<a href="https://www.cnblogs.com/andyfengzp/p/6434287.html" target="_blank" rel="noopener">https://www.cnblogs.com/andyfengzp/p/6434287.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>SpringBoot2面试题整理</title>
      <link href="/2018/05/23/SpringBoot2%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2018/05/23/SpringBoot2%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong>什么是springboot</strong><br>        用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件）<br>                创建独立的spring引用程序 main方法运行<br>                嵌入的Tomcat 无需部署war文件<br>                简化maven配置<br>                自动配置spring添加对应功能starter自动化配置</p><p><strong>springboot常用的starter有哪些</strong><br>        spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持<br>        spring-boot-starter-data-jpa 数据库支持<br>        spring-boot-starter-data-redis redis数据库支持<br>        spring-boot-starter-data-solr solr支持<br>        mybatis-spring-boot-starter 第三方的mybatis集成starter</p><p><strong>springboot自动配置的原理</strong><br>        在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration<br>        会自动去maven中读取每个starter中的spring.factories文件  该文件里配置了所有需要被创建spring容器中的bean</p><p><strong>springboot读取配置文件的方式</strong><br>        springboot默认读取配置文件为application.properties或者是application.yml</p><p><strong>springboot集成mybatis的过程</strong><br>        添加mybatis的starter maven依赖<br>                <dependency><br>                        <groupid>org.mybatis.spring.boot</groupid><br>                        <artifactid>mybatis-spring-boot-starter</artifactid><br>                        <version>1.2.0</version><br>                </dependency><br>        在mybatis的接口中 添加@Mapper注解<br>        在application.yml配置数据源信息</p><p><strong>springboot如何添加【修改代码】自动重启功能</strong><br>        添加开发者工具集=====spring-boot-devtools</p><p><strong>什么是微服务</strong><br>        以前的模式是 所有的代码在同一个工程中 部署在同一个服务器中 同一个项目的不同模块不同功能互相抢占资源<br>        微服务 将工程根据不同的业务规则拆分成微服务 微服务部署在不同的机器上 服务之间进行相互调用<br>        Java微服务的框架有 dubbo（只能用来做微服务），spring cloud（提供了服务的发现，断路器等）</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>springBoot2 精髓 从构建小系统到架构分布式大系统学习笔记</title>
      <link href="/2018/05/23/toBeCompleted/springBoot2%20%E7%B2%BE%E9%AB%93%20%E4%BB%8E%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%B3%BB%E7%BB%9F%E5%88%B0%E6%9E%B6%E6%9E%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/23/toBeCompleted/springBoot2%20%E7%B2%BE%E9%AB%93%20%E4%BB%8E%E6%9E%84%E5%BB%BA%E5%B0%8F%E7%B3%BB%E7%BB%9F%E5%88%B0%E6%9E%B6%E6%9E%84%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%A7%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="Java-EE简介"><a href="#Java-EE简介" class="headerlink" title="Java EE简介"></a>Java EE简介</h1><h1 id="Spring-Boot基础"><a href="#Spring-Boot基础" class="headerlink" title="Spring Boot基础"></a>Spring Boot基础</h1><h2 id="检查Java环境和安装Java"><a href="#检查Java环境和安装Java" class="headerlink" title="检查Java环境和安装Java"></a>检查Java环境和安装Java</h2><h2 id="检查和配置Maven"><a href="#检查和配置Maven" class="headerlink" title="检查和配置Maven"></a>检查和配置Maven</h2><h2 id="Spring核心技术"><a href="#Spring核心技术" class="headerlink" title="Spring核心技术"></a>Spring核心技术</h2><h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><h2 id="集成MVC框架"><a href="#集成MVC框架" class="headerlink" title="集成MVC框架"></a>集成MVC框架</h2><h2 id="使用Controller"><a href="#使用Controller" class="headerlink" title="使用Controller"></a>使用Controller</h2><h2 id="URL-隐射到方法"><a href="#URL-隐射到方法" class="headerlink" title="URL 隐射到方法"></a>URL 隐射到方法</h2><h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><h2 id="验证框架"><a href="#验证框架" class="headerlink" title="验证框架"></a>验证框架</h2><h2 id="WebMvcConfigurer"><a href="#WebMvcConfigurer" class="headerlink" title="WebMvcConfigurer"></a>WebMvcConfigurer</h2><h1 id="视图技术"><a href="#视图技术" class="headerlink" title="视图技术"></a>视图技术</h1><h2 id="Beetle模板引擎"><a href="#Beetle模板引擎" class="headerlink" title="Beetle模板引擎"></a>Beetle模板引擎</h2><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h2 id="格式化函数"><a href="#格式化函数" class="headerlink" title="格式化函数"></a>格式化函数</h2><h2 id="直接调用Java"><a href="#直接调用Java" class="headerlink" title="直接调用Java"></a>直接调用Java</h2><h2 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h2><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><h2 id="安全输出"><a href="#安全输出" class="headerlink" title="安全输出"></a>安全输出</h2><h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h2 id="脚本引擎"><a href="#脚本引擎" class="headerlink" title="脚本引擎"></a>脚本引擎</h2><h2 id="JSON技术"><a href="#JSON技术" class="headerlink" title="JSON技术"></a>JSON技术</h2><h2 id="MVC分离开发"><a href="#MVC分离开发" class="headerlink" title="MVC分离开发"></a>MVC分离开发</h2><h1 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><h2 id="Spring-JDBC-Template"><a href="#Spring-JDBC-Template" class="headerlink" title="Spring JDBC Template"></a>Spring JDBC Template</h2><h2 id="BeetlSQL"><a href="#BeetlSQL" class="headerlink" title="BeetlSQL"></a>BeetlSQL</h2><h2 id="SQLManager内置CRUD"><a href="#SQLManager内置CRUD" class="headerlink" title="SQLManager内置CRUD"></a>SQLManager内置CRUD</h2><h2 id="使用SQLId"><a href="#使用SQLId" class="headerlink" title="使用SQLId"></a>使用SQLId</h2><h2 id="BeetlSQL的其他功能"><a href="#BeetlSQL的其他功能" class="headerlink" title="BeetlSQL的其他功能"></a>BeetlSQL的其他功能</h2><h1 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="Spring Data JPA"></a>Spring Data JPA</h1><h2 id="集成Spring-Data-JPA"><a href="#集成Spring-Data-JPA" class="headerlink" title="集成Spring Data JPA"></a>集成Spring Data JPA</h2><h2 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h2><h1 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h1><h2 id="配置SpringBoot"><a href="#配置SpringBoot" class="headerlink" title="配置SpringBoot"></a>配置SpringBoot</h2><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><h2 id="读取应用配置"><a href="#读取应用配置" class="headerlink" title="读取应用配置"></a>读取应用配置</h2><h2 id="SpringBoot自动装配"><a href="#SpringBoot自动装配" class="headerlink" title="SpringBoot自动装配"></a>SpringBoot自动装配</h2>]]></content>
      
      
    </entry>
    
    <entry>
      <title>activeMq的安装和基础</title>
      <link href="/2018/05/22/activeMq%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/05/22/activeMq%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<hr><p>申明：请尽量与我本博文所有的软件版本保持一致，避免不必要的错误。</p><p>所用软件版本列表：<br>    activeMq：apache-activemq-5.15.3-bin.tar.gz<br>    JDK8</p><p> 所用软件官方网站列表：<br>     activeMq官网：<a href="http://activemq.apache.org/" target="_blank" rel="noopener">http://activemq.apache.org/</a><br>    activeMq5.15.3：<a href="http://activemq.apache.org/activemq-5153-release.html" target="_blank" rel="noopener">http://activemq.apache.org/activemq-5153-release.html</a></p><h1 id="activeMq的基本介绍"><a href="#activeMq的基本介绍" class="headerlink" title="activeMq的基本介绍"></a>activeMq的基本介绍</h1><h2 id="ActiveMQ是什么"><a href="#ActiveMQ是什么" class="headerlink" title="ActiveMQ是什么"></a>ActiveMQ是什么</h2><p>ActiveMQ是Apache推出的，一款开源的，完全支持JMS1.1和J2EE1.4规范的JMS Provider实现的消息中间件（Message Oriented Middleware， MOM）</p><h2 id="ActiveMQ能干什么"><a href="#ActiveMQ能干什么" class="headerlink" title="ActiveMQ能干什么"></a>ActiveMQ能干什么</h2><p>最主要的功能就是：实现JMS Provider 用来帮助实现高可用、高性能、可伸缩、易用和安全的企业级面向消息服务的系统</p><h2 id="ActiveMQ特点"><a href="#ActiveMQ特点" class="headerlink" title="ActiveMQ特点"></a>ActiveMQ特点</h2><p>  完全支持JMS1.1和J2EE1.4规范（持久化，XA消息，事务）<br>  完全多种传送协议：in-VM，TCP，SSL，NIO，UDP，JGroups，JXTA<br>  可插拔的体系结构，可以灵活定制，如：消息存储方式、安全管理等<br>  很容易和Application Server集成使用<br>  多种语言和协议编写客户端。语言：Java，C，C++，C#，Ruby，Perl，Python，PHP<br>  从设计上保证了高性能的集群，客户端-服务器，点对点<br>  可以很容易和spring结合使用<br>  支持通过JDBC和journal提供高速的消息持久化<br>  支持与Axis的整合</p><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>  MOM基本功能：将消息以消息的形式，从一个应用程序传送到另一个或多个应用程序。<br>  MOM主要特点：</p><ol><li>消息一部接收，类似手机短信的行为，消息发送者不需要等待消息接受者的响应，减少软件多系统集成的耦合度；</li><li><p>消息可靠接收，确保消息在中间件可靠保存，只有接收方收到后才会删除消息，多个消息也可以组成原子事务</p><p>消息中间件的主要应用场景：<br>在多个系统间进行整合和通讯的时候，通常会要求：</p><ol><li>可靠传输，数据不能丢失，有的时候，也会要求不能重复传输；</li><li>异步传输，否则各个系统同步发送接收数据，互相等待，造成系统瓶颈</li></ol></li></ol><p>目前比较知名的消息中间件：<br>IBM MQSeries<br>BEA WebLogic JMS Server<br>Oracle AQ<br>Tibco<br>SwiftMQ<br>ActiveMQ：是免费的Java实现的消息中间件</p><h1 id="ActiveMq的安装和基本使用"><a href="#ActiveMq的安装和基本使用" class="headerlink" title="ActiveMq的安装和基本使用"></a>ActiveMq的安装和基本使用</h1><h2 id="下载并安装ActiveMQ服务器端"><a href="#下载并安装ActiveMQ服务器端" class="headerlink" title="下载并安装ActiveMQ服务器端"></a>下载并安装ActiveMQ服务器端</h2><ol><li><p>下载ActiveMQ<br> 在Linux系统中输入一下下载命令：<br> <code>wget http://mirrors.hust.edu.cn/apache//activemq/5.15.3/apache-activemq-5.15.3-bin.tar.gz</code></p></li><li><p>直接解压，然后拷贝到你要安装的位置就好了<br> <code>tar -zxvf apache-activemq-5.15.3-bin.tar.gz</code></p></li><li><p>启动运行</p><ol><li>普通启动：到ActiveMQ/bin下面，<code>./activemq start</code></li><li>启动并指定日志文件 <code>./activemq start &gt; /tmp/activemqlog</code></li></ol></li><li><p>检查是否已经启动<br>ActiveMQ默认采用61616端口提供JMS服务，使用8161端口提供管理控制台服务，执行以下命令便以检验是否已成功启动ActiveMQ服务：</p><ol><li>比如查看61616端口是否打开：<code>netstat -an | grep 61616</code></li><li>也可以直接查看控制台输出或者日志文件</li><li>还可以直接访问ActiveMQ的管理控制台页面： <a href="http://192.168.159.170:8161/admin/" target="_blank" rel="noopener">http://192.168.159.170:8161/admin/</a> 默认的用户名和密码都是admin/admin</li></ol><p>关闭ActiveMQ，可以用 ./activemq stop<br>  暴力点可以直接用<code>ps -ef | grep activemq</code> 来得到进程号，然后kill掉</p><p>不要忘记开放linux端口号<br>  <code>firewall-cmd --zone=public --add-port=8161/tcp --permanent</code><br>  <code>firewall-cmd --zone=public --add-port=61616/tcp --permanent</code><br>  重启防火墙：<code>firewall-cmd --reload</code><br>  查看开放的端口号：<code>firewall-cmd --list-ports</code></p></li></ol><p>ActiveMQ 后台管理页面：<br>       <img src="./images/1526984596857.jpg" alt="enter description here" title="1526984596857.jpg"></p><h1 id="基本的Queue消息发送"><a href="#基本的Queue消息发送" class="headerlink" title="基本的Queue消息发送"></a>基本的Queue消息发送</h1><h2 id="配置Maven所需的依赖，示例如下："><a href="#配置Maven所需的依赖，示例如下：" class="headerlink" title="配置Maven所需的依赖，示例如下："></a>配置Maven所需的依赖，示例如下：</h2><p>1.创建maven项目：<br>2.引入项目activemq依赖<br><img src="./images/1526991821022.jpg" alt="enter description here" title="1526991821022.jpg"><br>依赖代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.activemq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.xbean<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xbean-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="基本的生产者和消费者代码示例"><a href="#基本的生产者和消费者代码示例" class="headerlink" title="基本的生产者和消费者代码示例"></a>基本的生产者和消费者代码示例</h2><p>生产者 QueueSender代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueSender</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.159.170:61616"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从连接工厂获取连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">//启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//从连接中获取该次session会话，并设置事务</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建会话队列</span></span><br><span class="line">Destination destination = session.createQueue(<span class="string">"my-queue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建生产者</span></span><br><span class="line">MessageProducer producer = session.createProducer(destination);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="comment">//创建消息对象</span></span><br><span class="line">TextMessage message = session.createTextMessage(<span class="string">"message---"</span> + i);</span><br><span class="line"><span class="comment">//生产者发送消息</span></span><br><span class="line">producer.send(message);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">session.commit();</span><br><span class="line"><span class="comment">//关闭session会话</span></span><br><span class="line">session.close();</span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行生产者之后，后台会出现生产者的信息，如下图：<br><img src="./images/1526994502944.jpg" alt="enter description here" title="1526994502944.jpg"></p><p>消费者代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueReceiver</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//创建连接工厂</span></span><br><span class="line">ConnectionFactory connectionFactory = <span class="keyword">new</span> ActiveMQConnectionFactory(<span class="string">"tcp://192.168.159.170:61616"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接工厂获取连接</span></span><br><span class="line">Connection connection = connectionFactory.createConnection();</span><br><span class="line"><span class="comment">// 启动连接</span></span><br><span class="line">connection.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从连接中获取该次session会话，并设置事务</span></span><br><span class="line">Session session = connection.createSession(<span class="keyword">true</span>, Session.AUTO_ACKNOWLEDGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建会话队列</span></span><br><span class="line">Destination destination = session.createQueue(<span class="string">"my-queue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者</span></span><br><span class="line">MessageConsumer consumer = session.createConsumer(destination);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">//取出消息</span></span><br><span class="line">TextMessage message = (TextMessage) consumer.receive();</span><br><span class="line">session.commit();</span><br><span class="line">System.out.println(<span class="string">"收到消息："</span> + message.getText());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭session会话</span></span><br><span class="line">session.close();</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">connection.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台结果如下<br><img src="./images/1526994968264.jpg" alt="enter description here" title="1526994968264.jpg"><br><img src="./images/1526995010835.jpg" alt="enter description here" title="1526995010835.jpg"></p><h1 id="JMS基本概念和模型"><a href="#JMS基本概念和模型" class="headerlink" title="JMS基本概念和模型"></a>JMS基本概念和模型</h1><h2 id="JMS基本概念"><a href="#JMS基本概念" class="headerlink" title="JMS基本概念"></a>JMS基本概念</h2><p><strong>JSM是什么</strong><br>JMS Java Message Service，Java消息服务，是Java EE中的一个技术</p><p><strong>JMS规范</strong><br>  JMS定义了Java中访问消息中间件的接口，并没有给予实现，实现JMS接口的消息中间件称为JSM Provider，例如ActiveMQ</p><p><strong>JMS Provider</strong><br>  实现了JMS接口和规范的消息中间件<br><strong>JMS Message</strong><br> JMS的消息，JMS消息由以下三部分组成：</p><ol><li>消息头：每个消息头字段都有相应的getter和setter方法</li><li>消息属性：如果需要除消息头字段以为的值，那么可以使用消息属性</li><li>消息体：封装具体的消息数据</li></ol><p><strong>JMS Producer</strong><br>消息消费者，创建和发送JMS消息的客户端应用<br><strong>JMS Consumer</strong><br>消息消费者，接收和处理JMS消息的客户端应用</p><p>消息的消费可以采用以下两种方法之一：</p><ol><li>同步消费：通过调用消费者的receive方法从目的地中显示提取消息，receive方法可以一直阻塞到消息到达。</li><li>异步消费：客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。</li></ol><p><strong>JMS Domains</strong><br>消息传递域，JMS规范中定义了两种欧冠呢消息传递域：点对点（point-to-point，简写成PTP）消息传递域和发布/订阅消息传递域（publish/subscribe，简写成pub/sub）</p><ol><li><p>点对点消息传递域的特点如下：<br> （1） 每个消息只能有一个消费者<br> （2）消息的生产者和消费者之间没有时间上的关联性。无论消费者在生产者发送消息的时候是否处于运行状态，他都可以提取消息。<br> <img src="./images/1526996128681.jpg" alt="enter description here" title="1526996128681.jpg"></p><ol start="2"><li>发布/订阅消息传递域的特点如下：<br>（1）每个消息可以有多个消费者<br>（2）生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。</li></ol></li><li>在点对点消息传递域中，目的地被称为队列（queue）；在发布/订阅消息传递域中，目的地被称为主题（topic）<br><img src="./images/1526996412125.jpg" alt="enter description here" title="1526996412125.jpg"></li></ol><p><strong>Connection factory</strong><br>链接工厂，用来创建连接对象，以连接到JSM的provider<br><strong>JMS Connection</strong><br>封装了客户与JMS 提供者之间的一个虚拟的连接<br><strong>JMS Session</strong><br>是生产者和消费者的一个单线程上下文<br>  会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。<br><strong>Destination</strong><br>消息发送到的目的地<br><strong>Acknowledge</strong><br>签收<br><strong>Transaction</strong><br>事务<br><strong>JMS client</strong><br>用来收发消息的Java应用<br><strong>Non-JMS client</strong><br>使用JMS Provider本地API写的应用，用来替换JMS API实现收发消息的功能，通常会提供其他的一些特性，比如：CORBA、RMI等。<br><strong>Administered objects</strong><br>预定义的JMS对象，通常在provider规范中有定义，提供给JMS客户端来访问，比如：ConnectionFactory和Destination</p><h2 id="JMS的消息结构"><a href="#JMS的消息结构" class="headerlink" title="JMS的消息结构"></a>JMS的消息结构</h2><p><strong>JMS 消息由以下几个部分组成</strong><br>消息头、属性和消息体<br><strong>消息头包含消息的识别信息和路由信息，消息头包含一些标准的属性如下：</strong></p><ol><li>JMSDestination：由send方法设置</li><li>JMSDeliveryMode：由send方法设置</li><li>JMSExpiration：由send方法设置</li><li>JMSPriority：由send方法设置</li><li>JMSMessageID：由send方法设置</li><li>JMSTimestamp：由客户端设置</li><li>JMSCorrelationID：由客户端设置</li><li>JMSReplyTo：由客户端设置</li><li>JMSType：由客户端设置</li><li>JMSRedelivered：由JMS Provider设置</li></ol><p><strong>标准的JMS消息头包含以下属性：</strong></p><ol><li>JMSDestination：消息发送的目的地：主要是指Queue和Topic，自动分配</li><li>JMSDeliveryMode：传送模式。有两种：持久模式和非持久模式。一条持久性的消息应该被传送“一次仅仅一次”，这就意味着如果JMS提供者出现故障，该消息并不会丢失，它会在服务器回复之后再次传递。一条非持久的消息最多会传递一次，这意味着服务器出现故障，该消息将永远丢失。自动分配</li><li>JMSExpiration：消息过期时间，等于Destination的send方法中的timeToLive值加上发送时刻的GMT时间值。如果timeToLive值等于零，则JMSExpiration被设为零，表示该消息永不过期。如果发送后，在消息过期时间之后消息还没有被发送到目的地，则该消息被清除。自动分配</li><li>JMSPriority：消息优先级，从0-9十个级别，0-4是普通消息级别，5-9是加急消息。JMS不要求JMS Provider严格按照这十个优先级发送消息，但必须保证加急消息要优先于普通消息到达。默认是4级。自动分配</li><li>JMSMessageID：唯一识别每个消息的表示，由JMS Provider产生。自动分配</li><li>JMSTimestamp：一个JMS Provider在调用send（）方法时自动设置的。它是消息被发送和消费者实际接收的时间差。自动分配</li><li>JMSCorrelationID：用来连接到另一个消息，典型的应用是在回复消息中连接到原消息。在大多数情况下，JMSCorrelationID用于将一条消息标记为对JMSMessageID标示的上一条消息的应答，不过，JMSCorrelationID可以是任何值，不仅仅是JMSMessageID。由开发者设置</li><li>JMSReplyTo：提供本消息回复消息的目的地地址。由开发者设置</li><li>JMSType：消息类型的标识符。由开发者设置</li><li>JMSRedelivered：如果一个客户端收到一个设置了JMSRedelivered属性的消息，则表示可能客户端曾经在早些的时候接收到过该消息，但并没有签收（acknowledged）。如果该消息被重新传送，JMSRedelivered=true反之，JMSRedelivered=false。自动设置</li></ol><p><strong>消息体</strong><br>JMS API定义了5种消息体格式，也叫消息类型，可以使用不同形式发送接收数据，并可以兼容现有的消息格式。包括：TextMessage、MapMessage、ByteMessage、StreamMessage和ObjectMessage<br><strong>消息属性，包含以下三种类型的属性</strong></p><ol><li>应用程序设置和添加的属性，比如：<br>Message.setStringProperty(“username”,username);</li><li>JMS定义的属性<br>使用“JMSX”作为属性名的前缀，connection.getMetaData().getJMSXPropertyNames()，方法返回所有连接支持的JMSX属性的名字。</li><li>JMS供应商特定的属性<br><strong>JMS定义的属性如下：</strong></li><li>JMSXUserID：发送消息的用户标识，发送时提供商设置</li><li>JMSXAppID：发送消息的应用标识，发送时提供商设置</li><li>JMSXDeliveryCount：转发消息重试次数，第一次是1，第二次是2，…，发送时提供商设置</li><li>JMSXGroupID：消息所在消息组的标识，由客户端设置</li><li>JMSXGroupSeq：组成消息的序列号第一个消息是1，第二个是2，…，有客户端设置</li><li>JMSXProducerTXID：产生消息的事务的事务标识，发送时提供商设置</li><li>JMSXConsumerTXID：消费消息的事务的事务标识，接收时提供商设置</li><li>JMSXRcvTimestamp：JMS转发消息到消费者的时间，接收时提供商设置</li><li>JMSXState：假定存在一个消息库，它存储了每个消息的单独拷贝，且这些消息从原始消息被发送时开始。每个拷贝的状态有：1（等待），2（准备），3（到期）或4（保留）。由于状态与生产者和消费者无关，所以它不是由我们来提供，它是和在仓库中查找消息相关，因此JMS没有提供这种API。由供应商设置</li></ol><h1 id="JMS的可靠性机制"><a href="#JMS的可靠性机制" class="headerlink" title="JMS的可靠性机制"></a>JMS的可靠性机制</h1><h2 id="消息接收确认"><a href="#消息接收确认" class="headerlink" title="消息接收确认"></a>消息接收确认</h2><p>  JMS消息只有在被确认之后，才认为已经被成功消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。<br>  在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有一下三个可选值：</p><ol><li>Session.AUTO_ACKNOWLEDGE：当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。</li><li>Session.CLIENT_ACKNOWLEDGE：客户通过调用消息的acknowledge方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行，确认一个被消费的消息将自动确认所有已被会话消费的消息。例如：如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。</li><li>Session.DUPS_ACKNOWLEDGE：该选择只是会话迟钝的确认消息的提交。如果JMS provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的JMSRedelivered字段设置为true</li></ol><h2 id="消息持久性"><a href="#消息持久性" class="headerlink" title="消息持久性"></a>消息持久性</h2><p>PERSISTENT：指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失<br>NON_PERSISTENT：不要求JMS provider持久保存消息</p><h2 id="消息优先级"><a href="#消息优先级" class="headerlink" title="消息优先级"></a>消息优先级</h2><p>可以使用消息优先级来指示JMS provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4.需要注意的是，JMS provider并不一定保证安好优先级的顺序提交消息</p><h2 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h2><p>可以设置消息在一定时间后过期，默认是永不过期</p><h2 id="消息的临时目的地"><a href="#消息的临时目的地" class="headerlink" title="消息的临时目的地"></a>消息的临时目的地</h2><p>可以通过会话上的createTemporaryQueue方法和createTemporaryTopic方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息</p><h2 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h2><p>首先消息生产者必须使用PERSISTENT提交消息。客户可以通过会话上的createDurableSubscriber方法来创建一个持久订阅，该方法的第一个参数必须是topic。第二个参数是订阅的名称。<br>  JMS provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户，使用相同的连接工厂和连接的客户ID，相同的主题和相同的订阅名，再次调用会话上的createDurableSubscriber方法，那么该持久订阅就会被激活。JMS provider会向客户发送客户处于非激活状态时所发布的消息。<br>  持久订阅在某个时刻只能有一个激活的订阅者。持久订阅在创建之后会一直保留，直到应用程序调用会话上的unsubscribe方法。</p><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>  在一个JMS客户端，可以使用本地事务来组合消息的发送射接收。JMS Session接口提供了commit和rollback方法。事务提交意味着生产的所有消息被发送，消费的需所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被回复并重新提交，除非它们已经过期。<br>  事务性的会话总是牵涉到事务处理中，commit或rollback方法一旦被调用，一个事物就结束了，而另一个事务被开始。关闭事务性会话将回滚其中的事务。<br>  需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事物中等待接收该消息的回复，那么程序将被挂起，因为直到事务提交，发送操作才会真正执行。<br>  需要注意的还有一个，消息的生产和消费不能包含在同一个事务中。</p><h2 id="JMS的PTP模型"><a href="#JMS的PTP模型" class="headerlink" title="JMS的PTP模型"></a>JMS的PTP模型</h2><p><strong>JMS PTP</strong>模型定义了客户端如何向队列发送消息，从队列接收消息，以及浏览队列中的消息。<br>  PTP模型是基于队列的，生产者发消息到队列，消费者从队列接收消息，队列的存在使得消息的异步传输成为可能。和右键系统中的邮箱一样，队列可以包含各种消息，JMS Provider提供工具管理队列的创建、删除。<br><strong>PTP的一些特点</strong></p><ol><li>如果在session关闭时，有一些消息已经被接收到，但还没有被签收（acknowledged），那么，当消费者下次连接到相同的队列时，这些消息还会被再次接收</li><li>如果用户在receive方法 中设定了消息选择条件，那么不符合条件的消息会留在队列中，不会被接收到</li><li>队列可以长久地保存消息直到消费者接收消息。消费者不需要因为担心消息会丢失而时刻和队列保持激活的连接状态，充分体现了异步传输模式的优势</li></ol><h2 id="JMS的Pub-Sub模型"><a href="#JMS的Pub-Sub模型" class="headerlink" title="JMS的Pub/Sub模型"></a>JMS的Pub/Sub模型</h2><p><strong>JMS Pub/Sub</strong>模型定义了如何向一内容节点发布和订阅消息，这些节点被称作topic<br>主题可以被认为是消息的传输中介，发布者（publisher）发布消息到主题，订阅者（subscribe）从主题订阅消息。主题使得消息订阅者和消息发布者保持相互的独立，不需要接触即可保持消息的传递。<br><strong>Pub/Sub的一些特点</strong></p><ol><li>消息订阅分为非持久订阅和持久订阅<br> 非持久订阅只有当客户端处于激活状态，也就是JMS provider保持连接状态才能收到发送到某个主题的消息，而当客户端处于离线的状态，这个时间段发到主题的消息将会丢失，永远不会收到。<br> 持久订阅时，客户端向JMS注册一个识别自己身份的ID，当这个客户端处于离线时，JMS provider会为这个ID保存所有发送到主题的消息，当客户端处于离线时，JMS Provider会为这个ID保持所有发送到主题的消息，当客户再次连接到JMS Provider时，会根据自己的ID得到所有当自己处于离线时发送到主题的消息。</li><li>如果用户在receive方法中设定了消息选择条件，那么不符合条件的消息不会被接收</li><li>非持久订阅状态下，不能恢复或重新派送一个未签收的消息。只有持久订阅才能恢复或重新派送一个未签收的消息。</li><li>当所有的消息必须被接收，则用持久订阅。当丢失消息能够被容忍，则用非持久订阅</li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>搭建github个人博客</title>
      <link href="/2018/05/21/%E6%90%AD%E5%BB%BAgithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/05/21/%E6%90%AD%E5%BB%BAgithub%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>前言：电脑系统为window 10专业版，64位</p><p><strong>相关步骤：</strong></p><p>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下<br><img src="/images/githubBlog/1526913209674.jpg" alt="enter description here" title="1526913209674.jpg"></p><p> 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择<br> <img src="/images/githubBlog/1526913249105.jpg" alt="enter description here" title="1526913249105.jpg"></p><p><em>注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图</em><br><img src="/images/githubBlog/1526913339718.jpg" alt="enter description here" title="1526913339718.jpg"></p><p> 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README<br><img src="/images/githubBlog/1526913655293.jpg" alt="enter description here" title="1526913655293.jpg"></p><p>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。<br><img src="/images/githubBlog/1526913543645.jpg" alt="enter description here" title="1526913543645.jpg"><br><em>因我之前已经建好了，所以上一步只能用test名字代替测试，下面的都正常用hlmk</em></p><p> 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面<br><img src="/images/githubBlog/1526913709966.jpg" alt="enter description here" title="1526913709966.jpg"></p><p>输入npm install hexo -g，开始安装Hexo<br><img src="/images/githubBlog/1526913731253.jpg" alt="enter description here" title="1526913731253.jpg"></p><p>输入hexo -v，检查hexo是否安装成功<br><img src="/images/githubBlog/1526913740128.jpg" alt="enter description here" title="1526913740128.jpg"></p><p>输入hexo init，初始化该文件夹（有点漫长的等待。。。）<br><img src="/images/githubBlog/1526913749309.jpg" alt="enter description here" title="1526913749309.jpg"><br><em>分割线–</em><br><img src="/images/githubBlog/1526913760169.jpg" alt="enter description here" title="1526913760169.jpg"></p><p>看到后面的“Start blogging with Hexo！”，激动有木有！！！！！</p><p>输入npm install，安装所需要的组件<br><img src="/images/githubBlog/1526913899957.jpg" alt="enter description here" title="1526913899957.jpg"></p><p>输入hexo g，首次体验Hexo<br><img src="/images/githubBlog/1526913912180.jpg" alt="enter description here" title="1526913912180.jpg"></p><p> 输入hexo s，开启服务器，访问该网址，正式体验Hexo<br><img src="/images/githubBlog/1526913926853.jpg" alt="enter description here" title="1526913926853.jpg"></p><p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号<br><img src="/images/githubBlog/1526913948340.jpg" alt="enter description here" title="1526913948340.jpg"></p><p>那么出现如下图就成功了<br><img src="/images/githubBlog/1526913958068.jpg" alt="enter description here" title="1526913958068.jpg"></p><p> 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）<br><img src="/images/githubBlog/1526913969715.jpg" alt="enter description here" title="1526913969715.jpg"></p><p>上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱</p><p>输入cd ~/.ssh，检查是否由.ssh的文件夹<br><img src="/images/githubBlog/1526913978185.jpg" alt="enter description here" title="1526913978185.jpg"></p><p>输入ls，列出该文件下的内容。下图说明存在<br><img src="/images/githubBlog/1526914039169.jpg" alt="enter description here" title="1526914039169.jpg"></p><p> 输入ssh-keygen -t rsa -C “<a href="mailto:929762930@qq.com" target="_blank" rel="noopener">929762930@qq.com</a>”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\Users\Administrator.ssh）。<br><img src="/images/githubBlog/1526914051384.jpg" alt="enter description here" title="1526914051384.jpg"></p><p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent<br><img src="/images/githubBlog/1526914067478.jpg" alt="enter description here" title="1526914067478.jpg"></p><p> 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent<br><img src="/images/githubBlog/1526914114518.jpg" alt="enter description here" title="1526914114518.jpg"></p><p> 登录Github，点击头像下的settings，添加ssh<br><img src="/images/githubBlog/1526914130644.jpg" alt="enter description here" title="1526914130644.jpg"></p><p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去<br><img src="/images/githubBlog/1526914140464.jpg" alt="enter description here" title="1526914140464.jpg"></p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了<br><img src="/images/githubBlog/1526914152124.jpg" alt="enter description here" title="1526914152124.jpg"></p><p>问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决</p><p>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key</p><p>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href="mailto:xxx@xxx.com" target="_blank" rel="noopener">xxx@xxx.com</a>“</p><p>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存</p><p>测试：<br>在终端 ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><p>6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）<br><img src="/images/githubBlog/1526914196527.jpg" alt="enter description here" title="1526914196527.jpg"></p><p>repo值是你在github项目里的ssh（右下角）<br><img src="/images/githubBlog/1526914230324.jpg" alt="enter description here" title="1526914230324.jpg"></p><p>7、新建一篇博客，在cmd执行命令：hexo new post “博客名”<br><img src="/images/githubBlog/1526914249036.jpg" alt="enter description here" title="1526914249036.jpg"></p><p> 这时候在文件夹_posts目录下将会看到已经创建的文件<br><img src="/images/githubBlog/1526914259780.jpg" alt="enter description here" title="1526914259780.jpg"></p><p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save<br><img src="/images/githubBlog/1526914268610.jpg" alt="enter description here" title="1526914268610.jpg"></p><p>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了<br><img src="/images/githubBlog/1526914278457.jpg" alt="enter description here" title="1526914278457.jpg"></p><p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章<br><img src="/images/githubBlog/1526914299651.jpg" alt="enter description here" title="1526914299651.jpg"></p><p> 好了，到此为止，基本的hexo完成，下满就是选择自己满意的插件整合进去</p><p>我选用的插件地址是：<a href="https://material.viosey.com/" target="_blank" rel="noopener">https://material.viosey.com/</a><br>1.进入github页面下载<br><img src="/images/githubBlog/1526916181661.jpg" alt="enter description here" title="1526916181661.jpg"><br>下载zip文件<br><img src="/images/githubBlog/1526916231835.jpg" alt="enter description here" title="1526916231835.jpg"><br>参考文档安装<br><img src="/images/githubBlog/1526916316591.jpg" alt="enter description here" title="1526916316591.jpg"></p><p>2.将下载下来的文件按照文档说明，解压到themes目录，并且将问价夹改名为material<br><img src="/images/githubBlog/1526916597591.jpg" alt="enter description here" title="1526916597591.jpg"></p><p>3.将_config.yml文件内的theme:改为material<br><img src="/images/githubBlog/1526916670470.jpg" alt="enter description here" title="1526916670470.jpg"></p><p>4.将解压文件内的_config.template.yml复制一份并改名为_config.yml<br><img src="/images/githubBlog/1526916820311.jpg" alt="enter description here" title="1526916820311.jpg"></p><p>5.启动hexo<br><img src="/images/githubBlog/1526916908750.jpg" alt="enter description here" title="1526916908750.jpg"></p><p>6.本地页面访问<br><img src="/images/githubBlog/1526916962616.jpg" alt="enter description here" title="1526916962616.jpg"></p><p>7.发布到github<br><img src="/images/githubBlog/1526917303706.jpg" alt="enter description here" title="1526917303706.jpg"></p><p>8.github访问<br><img src="/images/githubBlog/1526917350648.jpg" alt="enter description here" title="1526917350648.jpg"></p><p>9.其他一些具体参数和发布文章，参考文档：<a href="https://material.viosey.com/docs/#/start" target="_blank" rel="noopener">https://material.viosey.com/docs/#/start</a></p><p>参考博客：<a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/21/hello-world/"/>
      <url>/2018/05/21/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
    
  
</search>
